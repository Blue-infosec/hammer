<?xml version="1.0" ?>
<!DOCTYPE extension SYSTEM "../extension.dtd">
<extension name="hammer" version="1.1.3">
  <summary>A library for defining parsers (character- or binary-oriented) inline.</summary>
  <description>...</description>

  <maintainers>
    <maintainer>
      <user>mlp</user>
      <name>Meredith L. Patterson</name>
      <email>mlp@upstandinghackers.com</email>
      <role>lead</role>
    </maintainer>
  </maintainers>
  
  <license>LGPL</license>
  
  <release>
    <version>0.1</version>
    <date>2013-11-15</date>
    <state>alpha</state>
    <notes>First cut of extension.</notes>
  </release>

  <deps language="c" platform="unix">
    <with testfile="include/hammer/hammer.h">Hammer C library</with>
    <header name="allocator.h"/>
    <header name="glue.h"/>
    <header name="hammer.h"/>
    <lib name="hammer" platform="unix"/>
  </deps>

  <class name="HParseResult">
    <property name="ast"/>
    <property name="type" type="string"/>
    <!-- not sure we actually need this -->
    <function name="free">
      <proto>void free()</proto>
      <summary>Deallocate a parse result</summary>
      <description>
	Free the memory allocated to a parse result when the result is no longer needed.
      </description>
      <code>
      </code>
    </function>    
  </class>

  <class name="HBenchmarkResults">
    <function name="report">
      <proto>void report()</proto>
      <summary>Output benchmarking results in a human-readable format</summary>
      <description>
      </description>
      <code>
      </code>
    </function>
  </class>

  <class name="HParser">
    <function name="parse">
      <proto>object HParseResult parse(string str)</proto>
      <summary>Parse an input</summary>
      <description>Top-level function to call a parser that has been built over some piece of input.</description>
      <code>
      </code>
    </function> -->
    <function name="compile">
      <proto>int compile(string backend, array params)</proto>
      <summary>Generate parse tables for the given parsing backend</summary>
      <description>
	Some of the parsing backends must transform a parser into a set of parse tables before they can be used. See the documentation for the parser backend in question for information about the [params] parameter, or pass in NULL for the defaults.
	
	Returns -1 if the grammar cannot be compiled with the specified options; 0 otherwise.
      </description>
      <code>
      </code>
    </function>
    <function name="benchmark">
      <proto>object HBenchmarkResults benchmark(array testcases)</proto>
      <summary>Benchmark this parser using all the applicable parsing backends against a set of test cases you provide</summary>
      <description>
      </description>
      <code>
      </code>
    </function>
  </class>

  <function role="public" name="hammer_token">
    <proto>object HParser hammer_token(string token)</proto>
    <summary>Parse a token (primitive)</summary>
    <description>
      Given a string, returns a parser that parses that string value.
      
      Result token type: string
    </description>
    <code>
    </code>
  </function>

  <function role="public" name="hammer_ch">
    <proto>object HParser hammer_ch(string ch)</proto>
    <summary>Parse a character (primitive)</summary>
    <description>
      Given a single character, returns a parser that parses that character.

      Result token type: string
    </description>
    <code>
    </code>
  </function>

  <function role="public" name="hammer_ch_range">
    <proto>object HParser hammer_ch_range(string lower, string upper)</proto>
    <summary>Parse a character within the given range (primitive)</summary>
    <description>
      Given two single-character bounds, lower and upper, returns a parser that parses a single character within the range [lower, upper] (inclusive).

      Result token type: string
    </description>
    <code>
    </code>
  </function>

  <function role="public" name="hammer_int_range">
    <proto>object HParser hammer_int_range(object HParser p, int lower, int upper)</proto>
    <summary>Parse an integer within the given range (primitive)</summary>
    <description>
      Given an integer parser, p, and two integer bounds, lower and upper, returns a parser that parses an integral value within the range [lower, upper] (inclusive).

      Result token type: int
    </description>
    <code>
    </code>
  </function>

  <function role="public" name="hammer_bits">
    <proto>object HParser hammer_bits(int len, bool sign)</proto>
    <summary>Parse a specified number of bits (primitive)</summary>
    <description>
      Returns a parser that parses the specified number of bits. sign == true if signed, false if unsigned.

      Result token type: int
    </description>
    <code>
    </code>
  </function>

  <function role="public" name="hammer_int64">
    <proto>object HParser hammer_int64()</proto>
    <summary>Parse a 64-bit signed integer (primitive)</summary>
    <description>
      Returns a parser that parses a signed 8-byte integer value.

      Result token type: int
    </description>
    <code>
    </code>
  </function>

  <function role="public" name="hammer_int32">
    <proto>object HParser hammer_int32()</proto>
    <summary>Parse a 32-bit signed integer (primitive)</summary>
    <description>
      Returns a parser that parses a signed 4-byte integer value.

      Result token type: int
    </description>
    <code>
    </code>
  </function>

  <function role="public" name="hammer_int16">
    <proto>object HParser hammer_int16()</proto>
    <summary>Parse a 16-bit signed integer (primitive)</summary>
    <description>
      Returns a parser that parses a signed 2-byte integer value.

      Result token type: int
    </description>
    <code>
    </code>
  </function>

  <function role="public" name="hammer_int8">
    <proto>object HParser hammer_int8()</proto>
    <summary>Parse an 8-bit signed integer (primitive)</summary>
    <description>
      Returns a parser that parses a signed 1-byte integer value.

      Result token type: int
    </description>
    <code>
    </code>
  </function>

  <function role="public" name="hammer_uint64">
    <proto>object HParser hammer_uint64()</proto>
    <summary>Parse a 64-bit unsigned integer (primitive)</summary>
    <description>
      Returns a parser that parses an unsigned 8-byte integer value.

      Result token type: int
    </description>
    <code>
    </code>
  </function>

  <function role="public" name="hammer_uint32">
    <proto>object HParser hammer_uint32()</proto>
    <summary>Parse a 32-bit unsigned integer (primitive)</summary>
    <description>
      Returns a parser that parses an unsigned 4-byte integer value.

      Result token type: int
    </description>
    <code>
    </code>
  </function>

  <function role="public" name="hammer_uint16">
    <proto>object HParser hammer_uint16()</proto>
    <summary>Parse a 16-bit unsigned integer (primitive)</summary>
    <description>
      Returns a parser that parses an unsigned 2-byte integer value.

      Result token type: int
    </description>
    <code>
    </code>
  </function>

  <function role="public" name="hammer_uint8">
    <proto>object HParser hammer_uint8()</proto>
    <summary>Parse an 8-bit unsigned integer (primitive)</summary>
    <description>
      Returns a parser that parses an unsigned 1-byte integer value.

      Result token type: int
    </description>
    <code>
    </code>
  </function>

  <function role="public" name="hammer_whitespace">
    <proto>object HParser hammer_whitespace(object HParser p)</proto>
    <summary>Parse something preceded by whitespace (higher-order)</summary>
    <description>
      Given a parser, p, returns a parser that skips any whitespace and then applies p.

      Result token type: p's result type
    </description>
    <code>
    </code>
  </function>

  <function role="public" name="hammer_left">
    <proto>object HParser hammer_left(object HParser p, object HParser q)</proto>
    <summary>Take the leftmost result of two parsers (higher-order)</summary>
    <description>
      Given two parsers, p and q, returns a parser that parses them in sequence but only returns p's result.

      Result token type: p's result type
    </description>
    <code>
    </code>
  </function>

  <function role="public" name="hammer_right">
    <proto>object HParser hammer_right(object HParser p, object HParser q)</proto>
    <summary>Take the rightmost result of two parsers (higher-order)</summary>
    <description>
      Given two parsers, p and q, returns a parser that parses them in sequence but only returns q's result.

      Result token type: q's result type
    </description>
    <code>
    </code>
  </function>

  <function role="public" name="hammer_middle">
    <proto>object HParser hammer_middle(object HParser p, object HParser x, object HParser q)</proto>
    <summary>Take the middle result of three parsers (higher-order)</summary>
    <description>
      Given three parsers, p, x, and q, returns a parser that parses them in sequence but only returns x's result.

      Result token type: x's result type
    </description>
    <code>
    </code>
  </function>

  <function role="public" name="hammer_action">
    <proto>object HParser hammer_action(object HParser p, callback f)</proto>
    <summary>Attach a semantic action to a parser (higher-order)</summary>
    <description>
      Given another parser, p, and a function, f, returns a parser that applies p, then applies f to everything in the AST of p's result.

      Result token type: any
    </description>
    <code>
    </code>
  </function>

  <function role="public" name="hammer_in">
    <proto>object HParser hammer_in(string charset)</proto>
    <summary>Parse a character that appears in charset (primitive)</summary>
    <description>
      Parse a single character in the given charset.

      Result token type: string
    </description>
    <code>
    </code>
  </function>

  <function role="public" name="hammer_not_in">
    <proto>object HParser hammer_not_in(string charset)</proto>
    <summary>Parse a character that does not appear in charset (primitive)</summary>
    <description>
      Parse a single character *not* in the given charset.

      Result token type: string
    </description>
    <code>
    </code>
  </function>

  <function role="public" name="hammer_end_p">
    <proto>object HParser hammer_end_p()</proto>
    <summary>Recognize the end-of-input (primitive)</summary>
    <description>
      A no-argument parser that succeeds if there is no more input to parse.

      Result token type: none.
    </description>
    <code>
    </code>
  </function>

  <function role="public" name="hammer_nothing_p">
    <proto>object HParser hammer_nothing_p()</proto>
    <summary>This parser always fails (primitive)</summary>
    <description>
      hammer_nothing_p is primarily useful when stubbing out a larger parser. If you define a rule as hammer_nothing_p(), the top-level parser will run, but if a rule containing hammer_nothing_p is invoked, the parse will fail.

      Result token type: there is no result token for this parser.
    </description>
    <code>
    </code>
  </function>

  <function role="public" name="hammer_sequence">
    <proto>object HParser hammer_sequence(array p_array)</proto>
    <summary>Apply a list of parsers sequentially (higher-order)</summary>
    <description>
      Given an array of parsers, p_array, apply each parser in order. The parse succeeds only if all parsers succeed.

      Result token type: array
    </description>
    <code>
    </code>
  </function>

  <function role="public" name="hammer_choice">
    <proto>object HParser hammer_choice(array p_array)</proto>
    <summary>Apply any one of a list of parsers (higher-order)</summary>
    <description>
      Given an array of parsers, p_array, apply each parser in order. The first parser to succeed produces the result; if no parsers succeed, the parse fails.

      Result token type: the type of the first successful parser's result
    </description>
    <code>
    </code>
  </function>

  <function role="public" name="hammer_butnot">
    <proto>object HParser hammer_butnot(object HParser p1, object HParser p2)</proto>
    <summary>Parse p1 but not p2 (higher-order)</summary>
    <description>
      Given two parsers, p1 and p2, this parser succeeds in the following cases:

      * if p1 succeeds and p2 fails (starting from the same place in the input stream)
      * if both succeed but p1's result is as long as or longer than p2's

      Result token type: p1's result type.
    </description>
    <code>
    </code>
  </function>

  <function role="public" name="hammer_difference">
    <proto>object HParser hammer_difference(object HParser p1, object HParser p2)</proto>
    <summary>Parse p1 but not p2 (higher-order)</summary>
    <description>
      Given two parsers, p1 and p2, this parser succeeds in the following cases:
      
      * if p1 succeeds and p2 fails (starting from the same place in the input stream)
      * if both succeed but p2's result is *strictly* shorter than p1's

      Result token type: p1's result type.
    </description>
    <code>
    </code>
  </function>

  <function role="public" name="hammer_xor">
    <proto>object HParser hammer_xor(object HParser p1, object HParser p2)</proto>
    <summary>Parse p1 or p2 but not both (higher-order)</summary>
    <description>
      Given two parsers, p1 and p2, this parser suceeds if *either* p1 or p2 succeed, but not if they both do.

      Result token type: the result type of whichever parser succeeded
    </description>
    <code>
    </code>
  </function>

  <function role="public" name="hammer_many">
    <proto>object HParser hammer_many(object HParser p)</proto>
    <summary>Parse zero or more instances of p (higher-order)</summary>
    <description>
      Given a parser, p, this parser succeeds for zero or more repetitions of p.

      Result token type: array
    </description>
    <code>
    </code>
  </function>

  <function role="public" name="hammer_many1">
    <proto>object HParser hammer_many1(object HParser p)</proto>
    <summary>Parse one or more instances of p (higher-order)</summary>
    <description>
      Given a parser, p, this parser succeeds for one or more repetitions of p.

      Result token type: array
    </description>
    <code>
    </code>
  </function>

  <function role="public" name="hammer_repeat_n">
    <proto>object HParser hammer_repeat_n(object HParser p, int n)</proto>
    <summary>Parse exactly n instances of p (higher-order)</summary>
    <description>
      Given a parser, p, this parser succeeds for exactly N repetitions of p.

      Result token type: array
    </description>
    <code>
    </code>
  </function>

  <function role="public" name="hammer_optional">
    <proto>object HParser hammer_optional(object HParser p)</proto>
    <summary>Mark a parser as optional, like ? in regular expressions (higher-order)</summary>
    <description>
      Given a parser, p, this parser succeeds with the value p parsed or with an empty result.

      Result token type: If p succeeded, the type of its result; if not, nothing.
    </description>
    <code>
    </code>
  </function>

  <function role="public" name="hammer_ignore">
    <proto>object HParser hammer_ignore(object HParser p)</proto>
    <summary>Apply p but leave its result out of the final AST (higher-order)</summary>
    <description>
      Given a parser, p, this parser succeeds if p succeeds, but doesn't include p's result in the final result.

      Result token type: none.
    </description>
    <code>
    </code>
  </function>

  <function role="public" name="hammer_sepBy">
    <proto>object HParser hammer_sepBy(object HParser p, object HParser sep)</proto>
    <summary>Parse a (possibly empty) sequence of values separated by a separator (higher-order)</summary>
    <description>
      Given a parser, p, and a parser for a separator, sep, this parser matches a (possibly empty) list of things that p can parse, separated by sep. For example, if p is hammer_many1(hammer_ch_range('0', '9')) and sep is hammer_ch(','), hammer_sepBy(p, sep) will match a comma-separated list of integers.

      Result token type: array
    </description>
    <code>
    </code>
  </function>

  <function role="public" name="hammer_sepBy1">
    <proto>object HParser hammer_sepBy1(object HParser p, object HParser sep)</proto>
    <summary>Parse a sequence of values separated by a separator (higher-order)</summary>
    <description>
      Given a parser, p, and a parser for a separator, sep, this parser matches a list of things that p can parse, separated by sep. Unlike hammer_sepBy, this ensures that the result has at least one element. For example, if p is hammer_many(hammer_ch_range('0', '9')), hammer_sepBy1(p, sep) will match a comma-separated list of integers.
      
      Result token type: array
    </description>
    <code>
    </code>
  </function>

  <function role="public" name="hammer_epsilon_p">
    <proto>object HParser hammer_epsilon_p()</proto>
    <summary>Parse the empty string (primitive)</summary>
    <description>
      This parser always returns a zero-length match, i.e., the empty string.

      Result token type: none
    </description>
    <code>
    </code>
  </function>

  <function role="public" name="hammer_length_value">
    <proto>object HParser hammer_length_value(object HParser length, object HParser value)</proto>
    <summary>Parse (length) repetitions of (value) (higher-order)</summary>
    <description>
      This parser applies its first argument to read an unsigned integer value, then applies its second argument that many times. length should produce an integer value; this is checked at runtime. Specifically, length's token type must be int.

      Result token type: array
    </description>
    <code>
    </code>
  </function>

  <function role="public" name="hammer_attr_bool">
    <proto>object HParser hammer_attr_bool(object HParser p, callback pred)</proto>
    <summary>Ensure that some property holds for the AST (higher-order)</summary>
    <description>
      This parser attaches a predicate function, which returns true or false, to a parser. The function is evaluated over the parser's result. The parse only succeeds if pred returns true. 

      hammer_attr_bool will check whether p's result exists and whether p's result AST exists; you do not need to check for this in your predicate function.

      Result token type: p's result type if pred succeeds, otherwise the parse fails.
    </description>
    <code>
    </code>
  </function>

  <function role="public" name="hammer_and">
    <proto>object HParser hammer_and(object HParser p)</proto>
    <summary>Verify that p succeeds, but don't actually apply it (higher-order)</summary>
    <description>
      This parser asserts that a conditional syntax is satisfied, but doesn't consume that conditional syntax. This is useful for lookahead. As an example:

      Suppose you already have a parser, hex_p, that parses numbers in hexadecimal format (including the leading "0x"). Then
        
        hammer_sequence(hammer_and(hammer_token("0x")), hex_p)

      checks to see whether there is a leading "0x", does not consume the "0x", then applies hex_p to parse the hexadecimal number.

      This parser succeeds if p succeeds, and fails if p fails.

      Result token type: none
    </description>
    <code>
    </code>
  </function>

  <function role="public" name="hammer_not">
    <proto>object HParser hammer_not(object HParser p)</proto>
    <summary>Verify that p does not succeed, and don't consume any input (higher-order)</summary>
    <description>
      This parser asserts that a conditional syntax is *not* satisfied, and doesn't consume the additional syntax. As a somewhat contrived example:

      Since hammer_choice applies its arguments in order, the following parser:

        hammer_sequence(hammer_ch('a'), hammer_choice(hammer_ch('+'), hammer_token('++')), hammer_ch('b'))

      will not parse "a++b", because once hammer_choice has succeeded, it will not backtrack and try other alternatives if a later parser in the sequence fails. Instead, you can force the use of the second alternative by turning the hammer_ch('+') alternative into a sequence with hammer_not:

        hammer_sequence(hammer_ch('a'), hammer_choice(hammer_sequence(hammer_ch('+'), hammer_not('+')), hammer_token('++')), hammer_ch('b'))

      If the input string is "a+b", the first alternative is applied; if the input string is "a++b", the second alternative is applied.
      
      Result token type: none
    </description>
    <code>
    </code>
  </function>

  <function role="public" name="hammer_indirect">
    <proto>object HParser hammer_indirect()</proto>
    <summary>Forward-declare a parser to be used recursively (higher-order)</summary>
    <description>
      Create a parser that calls out to another, as yet unknown, parser. Note that the inner parser must be bound later, using hammer_bind_indirect(). This can be used to create recursive parsers.

      Result token type: the type of whatever parser is bound to it with hammer_bind_indirect().
    </description>
    <code>
    </code>
  </function>

  <function role="public" name="hammer_bind_indirect">
    <proto>void hammer_bind_indirect(object HParser p)</proto>
    <summary>Set the inner parser of an indirect parser.</summary>
    <description>
      See hammer_indirect() for details.
    </description>
    <code>
    </code>
  </function>

</extension>
